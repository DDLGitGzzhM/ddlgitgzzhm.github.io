[{"content":"新一期的 TGE 目前分数 115 从 4.29 日的 75 分，经过 8 天，就飞升到了 142 分，总共差额 67 ,平均 9.5(除去当天) 简单可以计算出，top 层级的玩家基本上一天会刷个 10 分，资产人均 2分 加上 8分交易量 ，大概是 256u 115 + 11 * x = 142 + 10 * x x = 142 - 115 = 27\n按照这个趋势，我需要吃满 27 天， 不过 x 可以翻倍，从而缩短我的进程 策略更改 目前更改了一下策略，从钱包 飞到了 交易所\n从原先的 BASE 链 回到了 solana 和 bnb chain . Base链的滑点太高了，导致我每次都被吃了很多的费用\n我们可以看见 4. 我做了一笔 solana 的 popcat , 512u 实际到手 511.6u , 加上 0.02 + 0.01 的 gas , 总共一次 就 0.43u 5. 我同样做了一笔 bnb chain 的 b2 , 513u 实际到手 511.79u, 加上 0.43 + 0.43 的 gas , 总共一次 就 2.71u 6. 同样都设置的 滑点 0.5% , 很显然 bnb chain 那个滑点爆炸了 。 不过他的gas费也不低，虽然一次是 double 积分\n综上，目前策略预计改成 solana chain , per 512/trade.\n积分是递增的即 512, 1024,2048, 4096\n按照一次 0.43u 的磨损来看，我2u可以亏损 5 次，即512 * 4 = 2560 ，这样子会把 x 大成为 3，即我9天内就可以赶上. 总共损耗 18u\n如果采用限价单双倍的策略,我很容易吃到 4096 那么我 6.75 天就可以吃满 . 总共损耗 14u\nOther 行情 ： https://www.geckoterminal.com/zh/bsc/pools/0xc1a780989734a0e5df875cebe410748562e1c5e6\n","date":"2025-05-06T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-2/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-2/","title":"[Binance] 送钱活动 3"},{"content":"资产策略现状 自从第一篇笔记开始，现在每天都有一个 todo list 需要给 binance 刷一下交易量，有点ptsd了 DATE BUY SELL DIFF 04-29 513 509 4U 04-30 513 509 4U 04-30 513 509 4U 05-01 513 509 4U 05-02 513 509 4U 05-03 513 511 2U 05-04 513 510 3U 目前总共磨损 4 *5 + 5 = 25U , 预计磨损 100U 破防。 按照 4 U 一天计算的话，大概还有25天破防 现在积分 85 , 最近一波在 5月7号，大概还有3天, 预计我还可以刷 22 分 ，也就是 118 . 预计是 140 ，大概是赶不上 binance 活动整理 双倍积分 BINANCE 推出积分双倍计算双倍活动 。 用交易所的限价单 和 BINANCE CHAIN 上刷交易量都是以双倍的形式计算 2. 即交易量 512 u 的 会以1024U计算，多个1积分 binance chain 暂时不考虑，手续费实在是太贵了 那么限价单是否有购买的必要呢 ？ 用限价单的话，大概率磨损会多个 1U - 2U ,多花个 1U - 2U 购买1积分 实际上很不划算 . 而且对于限价单, 需要把资产从钱包转移到交易所，很麻烦 。 新链 binance 钱包推出了 Sonic 链的项目。 对于活跃用户会有空投的奖励\n新币打新 OBOL 活动时间 5.7 号，18:00 不确定积分多少，预计要 130 . 大概率达不到 ~ ","date":"2025-05-04T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-1/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-1/","title":"[Binance] 送钱活动 2"},{"content":"引导问题 整数求和 1 2 3 4 5 6 7 8 9 Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge). In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + ... + n. Input The input will consist of a series of integers n, one integer per line. Output For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer. 常规做法是 for-each 后对 sum 进行累加，然后输出 我们可以根据 等差数列高斯公式求得 (a + b) * n / 2 不过这题需要注意的是 4. 我们计算乘法的时候可能暴 int , 因为对于两个 int32 的数相乘必然会爆 int32 所以我们需要开辟成 int64 题目链接如下, 由于不支持 GO 所以不做\nhttps://vjudge.net/problem/HDU-1001\n例题 最小公倍数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 输入两个整数 a 和 b，请你编写一个函数，int lcm(int a, int b)，计算并输出 a 和 b 的最小公倍数。 输入格式 共一行，包含两个整数 a 和 b。 输出格式 共一行，包含一个整数，表示 a 和 b 的最小公倍数。 数据范围 1≤a,b≤1000 输入样例： 6 8 输出样例： 24 朴素做法\n我们从最大的数开始枚举，如 8,9,10\u0026hellip; 每次都判断是否能整除最小数 简单优化，我们可以直接枚举 最大数的倍数 。 可是最大数的倍数, 我们有很大概率爆int 的风险 正解\nlcm(A,B) = A * B / gcd(A,B) 优化一下 = A / gcd(A,B) * B 问题引导为 如何求最大公约数 Acwing-最小公倍数\n最大公约数 我们现在要求 10, 14 的最大公约数 。 我们假设 X 为这两个数的最大公约数，可以知道，对于 (14%10) 的余数，也应该是 X 的倍数 从而我们可以依次类推 (10,14) , (10,4) , (2,4), (2,0) 则 2 就是最大公约数 todo : 很抓马的一件事，我用 go 写这个程序 TLE 了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import( \u0026#34;fmt\u0026#34; ) func gcd(a,b int) int { if a \u0026gt; b { a,b = b,a } for ; a != 0 ; { a, b = b%a,a } return b } func main() { var n int fmt.Scan(\u0026amp;n) for i := 0 ; i \u0026lt; n ; i ++ { var a,b int fmt.Scan(\u0026amp;a,\u0026amp;b) fmt.Println(gcd(a,b)) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std ; int gcd(int a,int b) { int temp ; if(a \u0026gt; b) { temp = a; a = b ; b = temp; } for( ; a != 0 ; ) { temp = a; a = b%a; b = temp ; } return b ; } int main() { int a,b ; int n; cin\u0026gt;\u0026gt;n; for(int i = 1; i \u0026lt;= n ; i ++ ) { cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;gcd(a,b)\u0026lt;\u0026lt;endl; } } ","date":"2025-05-04T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/hdu-0x01-math/icpc-title_hu_6183ef0f9981e0b9.png","permalink":"https://ddlgitgzzhm.github.io/p/hdu-0x01-math/","title":"[Hdu] 数学基础"},{"content":" 目前积分是 55 分 没想到短短 4 日，积分要求就从 45 飞到 80 ，整整长了 35 分 目前策略是 2 + 5 = 7 , 4 * 7 = 28 怎么都追不上 预计更换策略 2 + 9 = 11 , 4 * 11 = 44 (diff : 16) , ( diff calc per 16 * 4 = 64 ) 预计更换策略 512 一周，吃不到也没办法了 。\n预计每次磨损 8 刀左右，大概就是 8 * 7 = 56 刀 * 7.2 = 403.2 人名币\n积分计算规则 积分策略 最近活动 往期活动 ","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity/","title":"[Binance] 送钱活动"},{"content":" 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。\n示例 1：\n输入：nums = [1,1,1], k = 2\n输出：2\n示例 2：\n输入：nums = [1,2,3], k = 3\n输出：2\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104\n-1000 \u0026lt;= nums[i] \u0026lt;= 1000\n-107 \u0026lt;= k \u0026lt;= 107\n思路 对于 需要找到 X + Y = K 的模型，我们统一想到使用 map[X-K] = Y 的优化，可以将 n^2 -\u0026gt; O(n)\n对于这题我们需要把子数组和看为X, 我们计算前缀和 SUM[i] 表示，以 i 结尾前面所有数值的和. 因为我们知道 K 所以我们并不需要去找到我们的 Y, 我们只需要保证，我们能全量的枚举出X 即 SUM[i]\n因此我们只需要ans = ans + map[sum[i] - K] 即可\ntips :\n当我们 sum[1] - K == 2 并且在 sum[3] - K == 2 , 那么我们是否重复计算了 [0~3] 的某些子数组呢 ? 结论是 : 我们 sum[3]-K == 2 的成立是由于引入了A[2] , 因此不存在重复计算\n1 2 3 4 5 6 7 8 9 10 11 12 func subarraySum(nums []int, k int) int { count := make(map[int]int) count[0] = 1 preSum := 0 ans := 0 for _ , v := range nums { preSum += v ans += count[preSum - k] count[preSum] ++ } return ans } ","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/leetcode-560/img_hu_8844cfe45398f3ed.png","permalink":"https://ddlgitgzzhm.github.io/p/leetcode-560/","title":"[LeetCode][hot100] 560. 和为 K 的子数组"},{"content":"1. 基础排序 1. 查询后排序 asc 升序 ascending desc 降序 descending 1 select device_id, age from user_profile order by age asc 牛客网题目链接\n牛客网题目链接 (降序排列)\n2. 查询后多列排序 多列排序使用, 隔开 不指定排序顺序，默认是 asc 1 2 3 4 5 select device_id,gpa,age from user_profile order by gpa asc, age asc SELECT device_id,gpa,age from user_profile order by gpa,age;默认以升序排列 SELECT device_id,gpa,age from user_profile order by gpa,age asc; SELECT device_id,gpa,age from user_profile order by gpa asc,age asc; 牛客网题目链接\n2. 基础操作符 1. 查找学校是北大的学生信息 我们可以通过 where 子句来筛选对应的记录 1 select device_id, university from user_profile where university = \u0026#39;北京大学\u0026#39; 该题背景 : device_id 和 university 为联合索引\n在这个背景下面，我们可以在查询的时候使用联合索引，少去一层回表查询的操作 todo , DBM 不会自己合上id吗\n1 Select device_id,university FROM user_profile where university = \u0026#34;北京大学\u0026#34; and device_id = user_profile.device_id; 牛客网题目链接\n2. 查询年龄大于 24岁的用户信息 引入逻辑运算符 \u0026gt; 以此类推还有 \u0026lt; , = , \u0026gt;= , \u0026lt;= , != , = 1 select device_id, gender, age,university from user_profile where age \u0026gt; 24 [牛客网题目链接](select device_id, gender, age,university from user_profile where age \u0026gt; 24)\n3. 查询某个年龄段的用户信息 使用 between and 和 \u0026gt;= and \u0026lt;= 没什么本质区别，性能和业务使用上无差别 不过相较于between and 逻辑表达式更灵活 1 2 3 4 5 select device_id, gender, age from user_profile where age \u0026gt;= 20 and age \u0026lt;= 23 SELECT device_id, gender, age FROM user_profile WHERE age BETWEEN 20 AND 23; 牛客网题目链接\n4. 查找除复旦大学的用户信息 NOT IN 可以比较多个值, 对于 \u0026lt;\u0026gt; != 如果需要比较多个值需要引入 and \u0026lt;\u0026gt; 和 != 没有本质区别，不过一般都是写 \u0026lt;\u0026gt; 除非团队开发有要求，那么使用 != 尽可能统一组内的代码风格 1 2 3 select device_id,gender,age,university from user_profile where university \u0026lt;\u0026gt; \u0026#39;复旦大学\u0026#39; select device_id,gender,age,university from user_profile where university != \u0026#39;复旦大学\u0026#39; select device_id,gender,age,university from user_profile where university NOT IN (\u0026#34;复旦大学\u0026#34;) 牛客网题目链接\n5. 用 where 过滤空值 可以单独是用 is not null 或者是单独使用 \u0026lt;\u0026gt; \u0026quot;\u0026quot; 但是实际业务最好是两个一起使用 ～ 1 2 3 select device_id,gender,age,university from user_profile where age is not null and age \u0026lt;\u0026gt; \u0026#34;\u0026#34; 牛客网题目链接\n","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/limit-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/limit-select/","title":"[SQL] 条件查询"},{"content":"1. 查询所有列 两种做法,一种是 *, 另外一种是全量的显示所有的列。 本质上这两个没什么区别\n从业务角度来看\n如果当前的 sql 并不打算查新增的列 则可以使用第一种 如果后续有列被删除了, 第二种也需要同步改动(当然生产环境很少有直接删除的) 从索引角度来看\n如果 剩下的字段建立了二级索引，那么第二种方法可以避免一次回表操作 如果没有二级索引(二级缩影需要覆盖整个查询的列)这两个其实是一样的 1 2 SELECT * FROM user_profile SELECT id,device_id,gender,age,university,province FROM user_profile; 牛客网题目链接\n2. 查询结果去重 select distinct 只用于列的去重 select group by 可以用于一些聚合操作 如 count , avg 1 2 select distinct university from user_profile select unviersity from user_profile group by unviersity 从性能上看\ndistinct 和 group by 没什么区别, 在只需要去重的场景 distinct 性能可能略好于 group by, 效率取决于 DISTINCT 从业务上看\n如果我们想要使用聚合函数, 如计算分组内的平均数 和 总数 那么必须使用 distinct 牛客网题目链接\n","date":"2025-04-24T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/primary-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/primary-select/","title":"[SQL] 基础查询"},{"content":"简要 对于一个温度显示系统，如果我们要显示不同的温度, 简单做法是直接写在一个 class 里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type tempV1 struct { temp float64 } func (t *tempV1) ShowCelsius() string { return fmt.Sprintf(\u0026#34;%.1f°C\u0026#34;, t.temp) } func (t *tempV1) ShowFahrenheit() string { return fmt.Sprintf(\u0026#34;%.1f°F\u0026#34;, t.temp*9/5+32) } func (t *tempV1) ShowKelvin() string { return fmt.Sprintf(\u0026#34;%.1fK\u0026#34;, t.temp+273.15) } 如果我们使用 SRP 的做法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type tempV2 struct{ temp float64 } func (t *tempV2) GetTemp() float64 { return t.temp } type TempDisplayed struct{ } func (d *TempDisplayed) Celsius(temp float64) string { return fmt.Sprintf(\u0026#34;%.1f°C\u0026#34;, temp) } func (d *TempDisplayed) Fahrenheit(temp float64) string { return fmt.Sprintf(\u0026#34;%.1f°F\u0026#34;, temp*9/5+32) } 从实际业务开发的角度来看\n第一种方法更适合做快速开发，也就是前期的造轮子阶段 第二种方法适合进行维护和新增以及复用功能 从微服务角度来看\n我们展示温度的功能应该单独的一个组件, 或者说是一个服务, 也就是我们如果新增了新的展示温度功能,我们不应该重启温度服务，只需要重启温度展示服务即可 从内存角度来看\n由于我们新增的 TempDisplayed 并没有实际的 VALUE,属于无状态的 CLASS , 不占用额外内存。从 BenchMark 的结果来看，每次操作内存分配次数都是 4 allocs/op, 每次操作分配字节数都是 32B/op 和预期的一样 即我们并没有花更多的内存代价,就实现了代码服务的隔离 1 2 3 4 5 pkg: GolangLearning/design-pattern cpu: 12th Gen Intel(R) Core(TM) i5-12400 BenchmarkTempV1_Allocs-12 3861781 310.1 ns/op 32 B/op 4 allocs/op BenchmarkTempV2_Allocs-12 3682756 290.2 ns/op 32 B/op 4 allocs/op PASS 进阶 todo\n参考 https://juejin.cn/post/6967279849597566984?searchId=2025042323171433459C03C38A4C01D6A7 https://juejin.cn/post/7385388449618493477?searchId=2025042323171433459C03C38A4C01D6A7\n","date":"2025-04-24T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/srp/srp_hu_d90b5e254788e6e7.png","permalink":"https://ddlgitgzzhm.github.io/p/srp/","title":"[设计模式] SRP 单一职责原则"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n","date":"2020-09-09T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://ddlgitgzzhm.github.io/p/test-chinese/","title":"文章的起源"}]