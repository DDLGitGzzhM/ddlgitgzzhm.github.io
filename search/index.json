[{"content":"快速幂 求 A^B 的最后三位数表示的整数 输入格式 输入数据包含多个测试实例 每个实例占一行，由两个正整数A和B组成（1 ≤ A,B ≤ 10000） 如果A=0且B=0，则表示输入结束，不做处理 输出格式 对于每个测试实例，输出A^B的最后三位表示的整数 每个输出占一行 输入输出示例 输入样例 输出样例 2 3 8 12 6 984 6789 10000 1 0 0 (无输出) 算法讲解 :\n对于 123^(234). 我们可以优化成 (123^2)^117, 再进一步优化成 ((123^2) * 123 )^116 同理往下, 我们可以发现, 我们的计算量由次幂来控制, 同时我们可以根据就性质来操作次幂的优化 3. 对于奇数 我们只需要拆成 ans = ans * a 的形式 4. 对于偶数 我们只需要拆成 a = a * a 的形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int qmi(int a, int b) { int ans = 1 ; while(b != 0) { if(b\u0026amp;1) ans = ans * a % 1000 ; a = a * a % 1000 ; b = b \u0026gt;\u0026gt; 1; } return ans % 1000 ; } int main() { int a, b; while(1) { cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if (a == 0 \u0026amp;\u0026amp; b == 0 ) { break ; } cout\u0026lt;\u0026lt;qmi(a,b)\u0026lt;\u0026lt;endl; } return 0; } vj题目链接\ntodo ","date":"2025-05-25T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/hdu-0x01-math-02/icpc-title_hu_6183ef0f9981e0b9.png","permalink":"https://ddlgitgzzhm.github.io/p/hdu-0x01-math-02/","title":"[Hdu] 数学基础 day2"},{"content":"练习 统计复旦用户8月练题情况 题目：现在运营想要了解复旦大学的每个用户在8月份练习的总题目数和回答正确的题目数情况，请取出相应明细数据，对于在8月份没有练习过的用户，答题数结果返回0。\n表结构：\n用户信息表 user_profile id device_id gender age university gpa active_days_within_30 1 2138 male 21 北京大学 3.4 7 2 3214 male 20 复旦大学 3.2 15 练习明细表 question_practice_detail id device_id question_id result date 1 2138 111 wrong 2021-05-03 2 3214 112 wrong 2021-08-01 3 3214 113 right 2021-08-15 4 3214 114 wrong 2021-08-20 输出示例：\ndevice_id university question_cnt right_question_cnt 3214 复旦大学 3 1 5432 复旦大学 0 0 **题目要求解析 : **\n需要 用户, 做题数量, 最对数量 的一张子表 cout(), sum(), group by device_id 需要 用户, university 的一张子表 where university = 我们结果集是 2 表, left join 上 1 表. 对于 NULL 的情况 4. 我们需要使用 COALESCE() 处理一下 其他考点, 日期函数 month() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 select b.device_id, b.university, COALESCE(temp.question_cnt, 0) AS question_cnt, COALESCE(temp.right_question_cnt, 0) AS right_question_cnt from ( select device_id, university from user_profile as u where u.university = \u0026#39;复旦大学\u0026#39; ) as b left join ( select device_id, count(question_id) as question_cnt, SUM(CASE WHEN result = \u0026#39;right\u0026#39; THEN 1 ELSE 0 END) AS right_question_cnt from question_practice_detail where month(date) = 8 group by device_id ) as temp on b.device_id = temp.device_id 另外一个做法, 聚合之后在做 聚合函数的计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SELECT u.device_id, u.university, COUNT(qpd.question_id) AS question_cnt, SUM(CASE WHEN qpd.result = \u0026#39;right\u0026#39; THEN 1 ELSE 0 END) AS right_question_cnt FROM user_profile u LEFT JOIN question_practice_detail qpd ON u.device_id = qpd.device_id AND qpd.date BETWEEN \u0026#39;2021-08-01\u0026#39; AND \u0026#39;2021-08-31\u0026#39; WHERE u.university = \u0026#39;复旦大学\u0026#39; GROUP BY u.device_id, u.university ORDER BY u.device_id; 牛客题目链接\n浙大不同难度题目的正确率 题目：现在运营想要了解浙江大学的用户在不同难度题目下答题的正确率情况，请取出相应数据，并按照准确率升序输出。\n表结构：\n用户信息表 user_profile id device_id gender age university gpa active_days_within_30 question_cnt answer_cnt 1 2138 male 21 北京大学 3.4 7 2 12 2 3214 male 20 浙江大学 3.8 15 5 25 练习明细表 question_practice_detail id device_id question_id result 1 3214 111 wrong 2 3214 112 right 3 3214 113 right 4 2138 114 wrong 题目难度表 question_detail question_id difficult_level 111 hard 112 easy 113 medium 114 easy 输出要求：\n只统计浙江大学用户 计算不同难度题目的正确率（正确答题数/总答题数） 正确率保留4位小数 按correct_rate升序排列 输出示例：\ndifficult_level correct_rate hard 0.0000 easy 0.5000 medium 1.0000 题目要求解析 :\n首先需要一张表 浙江大学表 device_id, university 然后还需要一张表 用户做题难度表, device_id, question_id, diffcult_level 所以我们先聚合上面1的 TABLE, 然后再 JOIN 2 的 TABLE 最后计算答案 这里有一个偷鸡的办法, 由于 LEFT JOIN 聚合出了 NULL 的列, 最后分组操作的时候, 使用 having 过滤了一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 select qd.difficult_level as difficult_level, round(sum(if( temp.result = \u0026#39;right\u0026#39;, 1, 0)) / count(temp.result),4)as correct_rate from ( select qpd.device_id , qpd.question_id, qpd.result from user_profile as u left join question_practice_detail as qpd on qpd.device_id = u.device_id and u.university = \u0026#39;浙江大学\u0026#39; ) as temp left join question_detail as qd on temp.question_id = qd.question_id group by qd.difficult_level having difficult_level is not null order by correct_rate asc 其他解法 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 SELECT qd.difficult_level, ROUND( SUM(CASE WHEN qpd.result = \u0026#39;right\u0026#39; THEN 1 ELSE 0 END) * 1.0 / COUNT(qpd.question_id), 4 ) AS correct_rate FROM user_profile u JOIN question_practice_detail qpd ON u.device_id = qpd.device_id JOIN question_detail qd ON qpd.question_id = qd.question_id WHERE u.university = \u0026#39;浙江大学\u0026#39; GROUP BY qd.difficult_level ORDER BY correct_rate ASC; 牛客题目链接\nTODO 其他题目 ","date":"2025-05-25T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/com-practise-1/title_hu_d905cdfe259da164.png","permalink":"https://ddlgitgzzhm.github.io/p/com-practise-1/","title":"[SQL] 综合练习 1"},{"content":"文本函数 统计每种性别的人数 题目：现在运营举办了一场比赛，收到了一些参赛申请，表数据记录形式如下所示，现在运营想要统计每个性别的用户分别有多少参赛者，请取出相应结果\n示例：user_submit\ndevice_id profile blog_url 2138 180cm,75kg,27,male http:/url/bigboy777 根据示例，你的查询应返回以下结果：\ngender number male 2 female 1 新知识点\nQ : 如何拆分 一个列里面的数据, 然后进行分组\nA : SUBSTRING_INDEX(profile, ',', -1) AS gender\nprofile 需要处理的字符串字段 , 分隔符 -1 从字符串右侧开始截取, 第一个出现的分隔符后面的 所有内容 1 2 3 4 5 6 7 select SUBSTRING_INDEX(profile,\u0026#39;,\u0026#39;,-1) AS gender, COUNT(*) as number from user_submit group by gender 其他方法 : 注意famale 和 male 有重合的地方，所以不能直接like male，否则female 也会被统计进 ‘male’\n1 2 3 4 5 6 7 8 9 10 11 12 13 SELECT CASE WHEN profile LIKE \u0026#39;%,male\u0026#39; then \u0026#39;male\u0026#39; WHEN profile LIKE \u0026#39;%,female\u0026#39; then \u0026#39;female\u0026#39; else \u0026#39;其他\u0026#39; end as gender, COUNT(*) AS number FROM user_submit GROUP BY gender; SELECT IF(profile LIKE \u0026#39;%female\u0026#39;,\u0026#39;female\u0026#39;,\u0026#39;male\u0026#39;) gender,COUNT(*) number FROM user_submit GROUP BY gender; 题目链接\n送分题\n1 2 3 4 5 select device_id, SUBSTRING_INDEX(blog_url, \u0026#39;/\u0026#39;,-1) as user_name from user_submit 截取年龄 题目：现在运营举办了一场比赛，收到了一些参赛申请，表数据记录形式如下所示，现在运营想要统计每个年龄的用户分别有多少参赛者，请取出相应结果\n示例：user_submit\ndevice_id profile blog_url 2138 180cm,75kg,27,male http:/ur/bigboy777 根据示例，你的查询应返回以下结果：\nage number 27 1 25 1 \u0026hellip; \u0026hellip; 两段 substring_index 1 2 3 4 5 select SUBSTRING_INDEX( SUBSTRING_INDEX(profile, \u0026#39;,\u0026#39;, -2),\u0026#39;,\u0026#39;, 1) as age , count(*) as number from user_submit group by age 窗口函数 找出每个学校GPA最低的同学 题目：现在运营想要找到每个学校gpa最低的同学来做调研，请你取出每个学校的最低gpa。\n示例：user_profile\nid device_id gender age university gpa active_days_within_30 question_cnt answer_cnt 1 2138 male 21 北京大学 3.4 7 2 12 2 3214 male NULL 复旦大学 4.0 15 5 25 根据示例，你的查询结果应参考以下格式，输出结果按university升序排序：\ndevice_id university gpa 6543 北京大学 3.2 [id] [学校名] [最低gpa] Q : 题目要求求出一个 TopN 的问题\nA : 新知识点\n1 2 \u0026lt;窗口函数\u0026gt; over (partition by \u0026lt;用于分组的列名\u0026gt; order by \u0026lt;用于排序的列名\u0026gt;) 窗口函数 rank(), dense_rank, row_number\nrank() : 如果存在多个并列名次会占用, 即 1,1,1,4\ndense_rank() : 如果存在多个并列名次不会占用, 即 1,1,1,2\nrow_number() : 不占用,不并列. 即 1,2,3,4\n具体说明 :\n窗口函数知乎链接\n1 2 3 4 5 select device_id, university, gpa from ( select device_id, university, gpa , RANK() over (PARTITION BY university order by gpa) rk from user_profile ) a where a.rk = 1 另外由于这个只是一个 max-min 的问题, 我们同样可以是用 JOIN or 子表查询 的方法做\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 select u.device_id , u.university, u.gpa from user_profile as u inner join ( select min(gpa) as gpa, university from user_profile group by university ) as temp on temp.university = u.university and u.gpa = temp.gpa order by university SELECT device_id, university, gpa FROM user_profile u1 WHERE gpa = ( SELECT MIN(gpa) FROM user_profile u2 WHERE u2.university = u1.university ); 牛客题目链接\n计算每日累计利润 题目：在一张daily_profits表中，存储了公司每天的利润记录。请计算每一种产品每一天的累计利润，并按profit_date升序输出所有字段。\n具体要求：\n计算每一天的累计利润 输出结果按profit_date升序排列 表结构：daily_profits\nprofit_id profit_date profit 1 2024-01-01 100.00 2 2024-01-02 150.00 3 2024-01-03 200.00 输出示例：\nprofit_id profit_date profit cumulative_profit 1 2024-01-01 100.00 100.00 2 2024-01-02 150.00 250.00 3 2024-01-03 200.00 450.00 Q : 我们需要逐天的累加每个分组的结果\nA : 我们可以把整个结果集，看成一个分组。想要实现逐行累加，那么就需要使用 窗口函数 , 但是我们不需要 PARTITION BY 进行分组\n1 2 select * , sum(profit) over (order by profit_date) cumulative_profit from daily_profits 牛客题目链接\n基础数学函数 基本数学函数 题目：在一张 numbers 表中，存储了一些数值。请使用 SQL 的基本数学函数，计算每个数值的绝对值、向上取整、向下取整、四舍五入到一位小数，并输出这些计算结果。\n具体要求：\n计算每个数值的绝对值 计算每个数值的向上取整值 计算每个数值的向下取整值 计算每个数值四舍五入到一位小数 输出结果按 id 升序排列 表结构：numbers\nid value 1 3.14 2 -2.71 输出示例：\nid value absolute_value ceiling_value floor_value rounded_value 1 3.14 3.14 4 3 3.1 2 -2.71 2.71 -2 -3 -2.7 新知识点 :\nABS(), ceil(), floor(), round() 绝对值，向上取整，向下取整，精度 1 2 3 4 5 6 7 select *, abs(value) as absolute_value, ceil(value) as ceiling_value, #向上取整 floor(value) as floor_value, #向下取整 round(value,1) as rounded_value from numbers order by id ASC 牛客网题目链接\n","date":"2025-05-23T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/necessary-select-2/title_hu_d905cdfe259da164.png","permalink":"https://ddlgitgzzhm.github.io/p/necessary-select-2/","title":"[SQL] 必要函数 2"},{"content":"条件函数 计算25岁以上和以下的用户数量 以下是修复后的Markdown内容，保持引用格式并优化表格展示：\n题目：现在运营想要将用户划分为25岁以下和25岁及以上两个年龄段，分别查看这两个年龄段用户数量\n本题注意：age为null 也记为 25岁以下\n示例：user_profile\nid device_id gender age university gpa active_days_within_30 question_cnt answer_cnt 1 2138 male 21 北京大学 3.4 7 2 12 根据题目要求，你的查询应返回以下结果（注意age为null的情况应归类为25岁以下）：\nage_cut number 25岁以下 4 25岁及以上 3 新知识点\nQ : 这个 age_cut , 25岁以下 ，25岁以上 是怎么插进去的\nA : 原来 我们 SELECT CONST STRING, 那么就会输出对应的 STRING\nQ : 怎么进行判断 25 岁以下, 25岁以上\nA :\n第一种方法， 使用 CASE (WHEN ... ELSE) END 的形式 第二种方法， 使用 IF(JUDGE , TRUE, FALSE) 很明显 这种语句只支持两个结果 所以对于本体 我们的做法 是 SIWTCH ( CONST STRING ) FROM TABLE 的形式\n1 2 3 4 5 6 7 8 9 10 SELECT ( CASE WHEN age \u0026lt; 25 THEN \u0026#39;25岁以下\u0026#39; WHEN age \u0026gt;= 25 THEN \u0026#39;25岁及以上\u0026#39; ELSE \u0026#39;25岁以下\u0026#39; END ) as age_cut, count(*) as number from user_profile group by age_cut 1 2 3 4 5 6 7 select (case when age\u0026gt;=25 then \u0026#39;25岁及以上\u0026#39; else \u0026#39;25岁以下\u0026#39; end) as age_cut, count(*) as number from user_profile group by age_cut 坑点 :\n由于这里使用了 COUNT() 这个聚合函数，所以必须加上 GROUP BY 当我们涉及查询 既有聚合函数 COUNT,SUM,AVG,MAX,MIN , 又有普通列的时候，就必须用 GRUOP BY 分组后, 如果我们想要对结果进行筛选必须使用HAVING ,WHERE 是分组前筛选, HAVING 是分组后筛选 题目链接\n送分题\n日期函数 计算用户8月每天的练题数量 以下是修复后的Markdown内容，保持引用格式并优化表格展示：\n题目：现在运营想要计算出2021年8月每天用户练习题目的数量，请取出相应数据\n示例：question_practice_detail\nid device_id question_id result date 1 2138 111 wrong 2021-05-03 根据题目要求，你的查询应返回以下结果（按日期升序排列）：\nday question_cnt 13 5 14 2 新知识点\nQ : 如何获取 日期 day , month , year 的信息\nsql 支持使用 year(), month(), day() 的形式获取对应的 年月日 WEEKDAY() 返回星期索引 , 0 = 星期一 \u0026hellip; QUATER() 返回季度 , 范围1-4 MINUTE() , SECOND() 1 2 3 4 5 6 7 8 #获取当前系统的日期时间 SELECT NOW(); # 2021-12-22 13:50:58 #获取当前系统的日期 SELECT CURDATE(); # 2021-12-22 #获取当前系统的时间 SELECT CURTIME(); # 13:53:11 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #日期增加,使用函数date_add(date,INTERVAL exp type) #增加1天 SELECT DATE_ADD(\u0026#39;2021-12-22 13:50:58\u0026#39;, INTERVAL 1 DAY); # 2021-12-23 13:50:58 #增加1小时 SELECT DATE_ADD(\u0026#39;2021-12-22 13:50:58\u0026#39;, INTERVAL 1 HOUR); # 2021-12-23 14:50:58 #日期减少，使用函数date_sub(date,INTERVAL exp type) # 减少1天 SELECT DATE_SUB(\u0026#39;2021-12-01 13:50:58\u0026#39;, INTERVAL 1 DAY); # 2021-11-30 13:50:58 #其他间隔 INTERVAL 1 YEAR INTERVAL 1 MONTH INTERVAL 1 DAY INTERVAL 1 HOUR INTERVAL 1 MINUTE INTERVAL 1 SECOND 思路\n这题 在知道如何操作日期之后就很简单了 1 2 3 4 SELECT DAY(date) as day , count(*) as question_cnt from question_practice_detail WHERE YEAR(date) = 2021 and MONTH(date) = 8 group by day 计算用户的平均次日留存率 以下是修复后的Markdown内容，保持引用格式并优化表格展示：\n题目：现在运营想要查看用户在某天刷题后第二天还会再来刷题的留存率。请你取出相应数据\n示例：question_practice_detail\nid device_id question_id result date 1 2138 111 wrong 2021-05-03 根据示例，你的查询应返回以下结果（保留4位小数）：\navg_ret 0.3000 题目要求 :\n计算 用户连续两天 都做题的占比 注意一个用户一天可以做多个题 思路 :\n首先我们需要知道 如何比较 有一条数据 是 另外一条数据的 第二天 2. 我们可以使用上面学到的 DATE_ADD(DATE , INTERVAL X Y) 比较 如果 P1.DATE = DATE_ADD() 的话那么就说明相差一天 3. 因此我们肯定是 DAY 1 TABLE JOIN DAY 2 TABLE 4. 由于我们需要知道 DAY 1 的总数，所以我们需要 LEFT JOIN 1 2 3 4 5 6 7 8 9 10 11 SELECT ROUND( SUM( IF(p2.device_id IS NOT NULL ,1,0)) / COUNT(*) ,4 ) as avg_ret FROM (SELECT DISTINCT device_id, date from question_practice_detail) as p1 LEFT JOIN (SELECT DISTINCT device_id, date from question_practice_detail) as p2 ON p1.device_id = p2.device_id and p2.date = DATE_ADD(p1.date, INTERVAL 1 day) 牛客题目链接\n","date":"2025-05-08T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/necessary-select-1/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/necessary-select-1/","title":"[SQL] 必要函数"},{"content":"子查询 浙江大学用户题目回答情况 题目：现在运营想要查看所有来自浙江大学的用户题目回答明细情况，请你取出相应数据\n示例：question_practice_detail\nid device_id question_id result 1 2138 111 wrong 第一行表示：id为1的用户的常用信息为使用的设备id为2138，在question_id为111的题目上，回答错误\n示例：user_profile\nid device_id gender age university gpa active_days_within_30 question_cnt answer_cnt 1 2138 male 21 北京大学 3.4 7 2 12 第一行表示：id为1的用户的常用信息为使用的设备id为2138，性别为男，年龄21岁，北京大学，gpa为3.4，在过去的30天里面活跃了7天，发帖数量为2，回答数量为12\n根据示例，你的查询应返回以下结果，查询结果根据question_id升序排序：\ndevice_id question_id result 2315 115 right 两个表 根据 device_id 关联, 题目需要我们聚合 qpd 表的 question_id 和 result 字段 条件是 up 表的 university 是 浙江大学 第一时间没有想到 子查询 , 直接使用 JOIN ON了 1 2 3 4 5 6 7 8 select qpd.device_id,qpd.question_id,qpd.result from user_profile as up join question_practice_detail as qpd on up.device_id = qpd.device_id where up.university = \u0026#39;浙江大学\u0026#39; order by qpd.question_id 子查询代码如下\n1 2 3 4 5 6 select device_id, question_id, result from question_practice_detail where question_practice_detail.device_id in ( select device_id from user_profile where university = \u0026#39;浙江大学\u0026#39; ) 牛客题目链接\n链接查询 统计每个学校的答过题的用户的平均答题数 题目：查找每个学校用户的平均答题数目（某学校用户平均答题数量计算方式为该学校用户答题总次数除以答过题的不同用户个数）\n表结构说明：\nuser_profile 用户信息表：\ndevice_id：终端编号（每个用户有唯一的一个终端） gender：性别 age：年龄 university：用户所在的学校 gpa：该用户平均学分绩点 active_days_within_30：30天内的活跃天数 question_practice_detail 答题情况明细表：\nquestion_id：题目编号 result：答题结果 示例数据：\nuser_profile：\ndevice_id gender age university gpa active_days_within_30 2138 male 21 北京大学 3.4 7 question_practice_detail：\ndevice_id question_id result 2138 111 wrong 要求：计算每个学校用户的平均答题数目（答题总次数/答过题的不同用户数），结果保留4位小数，按university升序排序\n预期输出示例：\nuniversity avg_answer_cnt 北京大学 1.0000 题目要求\n根据 up 表的 university 聚合出 qpd 表中 每所大学的 平均答题数, 即 university 对应有的 device_id 总共有多少个记录在 qpd 表中 这里有一个逻辑坑点 , distinct up.device_id 一开始认为 device_id 必然是唯一的 。但是我们 join on 之后，由于 qpd表的 device_id 是有多个的，所以我们最后用于计算的分母需要DISTINCT 1 2 3 4 5 6 7 8 9 10 11 select up.university, round( count(qd.question_id)/count(distinct up.device_id), 4) as avg_answer_cnt from user_profile as up JOIN question_practice_detail as qd on up.device_id = qd.device_id group by up.university order by up.university 牛客题目链接\n统计每个学校各难度的用户平均刷题数 以下是修复后的Markdown内容，保持引用格式，优化了表格展示和换行：\n题目：运营想要计算一些参加了答题的不同学校、不同难度的用户平均答题量，请你写SQL取出相应数据\n用户信息表：user_profile\nid device_id gender age university gpa active_days_within_30 question_cnt answer_cnt 1 2138 male 21 北京大学 3.4 7 2 12 题库练习明细表：question_practice_detail\nid device_id question_id result 1 2138 111 wrong 表：question_detail\nid question_id difficult_level 1 111 hard 请你写一个SQL查询，计算不同学校、不同难度的用户平均答题量，根据示例，你的查询应返回以下结果(结果在小数点位数保留4位，4位之后四舍五入)：\nuniversity difficult_level avg_answer_cnt 北京大学 hard 1.0000 题目要求 :\n首先需要 up 表的 university 另外需要 qd 表的 diffcult 其次需要计算 count(same-diffcult-question) / count(same-university-device-id) 思路 :\n对于三张表的查询 , 我们先优化到 两张表的查询，拆子问题 , 我们可以先聚合 qd 和qpd 这两张表 , 知道每个 题目的难度 相当于我们聚合了一张 带有难度信息的 qpd 然后我们使用 这个new qpd 再去和 UP 聚合计算一下 对应的 question_id/device_id group by (university, diffcult) 即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 select up.university, temp.difficult_level, count(temp.question_id) / count(distinct up.device_id) as avg_answer_cnt from user_profile as up join ( select qpd.device_id,qpd.question_id, qd.difficult_level from question_practice_detail as qpd join question_detail as qd on qpd.question_id = qd.question_id ) as temp on up.device_id = temp.device_id group by up.university, temp.difficult_level order by up.university 牛客题目链接\n牛客经验+1\n组合查询 查找山东大学或者性别为男生的信息 以下是修复后的Markdown内容，保持引用格式并优化表格展示：\n题目：现在运营想要分别查看学校为山东大学或者性别为男性的用户的device_id、gender、age和gpa数据，请取出相应结果，结果不去重。\n示例：user_profile\nid device_id gender age university gpa active_days_within_30 question_cnt answer_cnt 1 2138 male 21 北京大学 3.4 7 2 12 根据示例，你的查询应返回以下结果（注意输出的顺序，先输出学校为山东大学再输出性别为男生的信息）：\ndevice_id gender age gpa 5432 male 25 3.8 题目要求 :\n连续查两遍这个表, 第一遍是 山东大学, 第二遍是男性 然后组合输出 思路 :\n一开始以为是 SELECT WHERE OR 的形式,但是发现 2. 第一, 不能查重复数据 ,即山东大学 和 male 如果是一条数据,应该查出两条 3. 第二不好排序,因为UNIVERSITY\n这题纯属新知识点 UNION ALL 不去除重复数据 ,UNOIN 去除重复数据\n1 2 3 4 5 6 7 select device_id, gender,age, gpa from user_profile where university = \u0026#39;山东大学\u0026#39; union all select device_id, gender, age , gpa from user_profile where gender = \u0026#39;male\u0026#39; 牛客题目链接\n留坑 JOIN ,LEFT JOIN, RIGHT JOIN 子查询 ,视图的概念 UNION ALL的性能 ,业务上的使用 ","date":"2025-05-07T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/multi-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/multi-select/","title":"[SQL] 多表查询"},{"content":"新一期的 TGE 目前分数 115 从 4.29 日的 75 分，经过 8 天，就飞升到了 142 分，总共差额 67 ,平均 9.5(除去当天) 简单可以计算出，top 层级的玩家基本上一天会刷个 10 分，资产人均 2分 加上 8分交易量 ，大概是 256u 115 + 11 * x = 142 + 10 * x x = 142 - 115 = 27\n按照这个趋势，我需要吃满 27 天， 不过 x 可以翻倍，从而缩短我的进程 策略更改 目前更改了一下策略，从钱包 飞到了 交易所\n从原先的 BASE 链 回到了 solana 和 bnb chain . Base链的滑点太高了，导致我每次都被吃了很多的费用\n我们可以看见 4. 我做了一笔 solana 的 popcat , 512u 实际到手 511.6u , 加上 0.02 + 0.01 的 gas , 总共一次 就 0.43u 5. 我同样做了一笔 bnb chain 的 b2 , 513u 实际到手 511.79u, 加上 0.43 + 0.43 的 gas , 总共一次 就 2.71u 6. 同样都设置的 滑点 0.5% , 很显然 bnb chain 那个滑点爆炸了 。 不过他的gas费也不低，虽然一次是 double 积分\n综上，目前策略预计改成 solana chain , per 512/trade.\n积分是递增的即 512, 1024,2048, 4096\n按照一次 0.43u 的磨损来看，我2u可以亏损 5 次，即512 * 4 = 2560 ，这样子会把 x 大成为 3，即我9天内就可以赶上. 总共损耗 18u\n如果采用限价单双倍的策略,我很容易吃到 4096 那么我 6.75 天就可以吃满 . 总共损耗 14u\nOther 行情 ： https://www.geckoterminal.com/zh/bsc/pools/0xc1a780989734a0e5df875cebe410748562e1c5e6\n","date":"2025-05-06T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-2/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-2/","title":"[Binance] 送钱活动 3"},{"content":"高级操作符练习 1 题目：现在运营想要找到male且GPA在3.5以上(不包括3.5)的用户进行调研，请你取出相关数据。\n业务场景中, 需要提前加上其他判断 gpa is not null 1 select device_id,gender,age,university,gpa from user_profile where gpa \u0026gt; 3.5 and gender = \u0026#39;male\u0026#39; 牛科练习题目\n高级操作符练习 2 题目：现在运营想要找到学校为北大或GPA在3.7以上(不包括3.7)的用户进行调研，请你取出相关数据（使用OR实现）\n就简单介绍了一下 or 怎么用 顾名思义 1 select device_id, gender, age, university, gpa from user_profile where university = \u0026#39;北京大学\u0026#39; or gpa \u0026gt; 3.7 牛科练习题目\nWhere in 和 Not in 题目：现在运营想要找到学校为北大、复旦和山大的同学进行调研，请你取出相关数据。\n顾名思义 todo 性能分析 @我 1 select device_id, gender,age,university,gpa from user_profile where university in (\u0026#39;北京大学\u0026#39;, \u0026#39;复旦大学\u0026#39;, \u0026#39;山东大学\u0026#39;) 牛科练习题目\n操作符混合运用 题目：现在运营想要找到gpa在3.5以上(不包括3.5)的山东大学用户 或 gpa在3.8以上(不包括3.8)的复旦大学同学进行用户调研，请你取出相应数据,取出的数据按照device_id升序排列\n1 2 3 4 5 6 7 select device_id, gender,age, university,gpa from user_profile where ( gpa \u0026gt; 3.5 and university = \u0026#39;山东大学\u0026#39; ) or (gpa \u0026gt; 3.8 and university = \u0026#39;复旦大学\u0026#39;) order by device_id asc 这里可以改为子查询的方式，时间或许会更短 1 2 3 4 5 6 7 select device_id, gender, age, university, gpa from user_profile where device_id in (select device_id from user_profile where gpa\u0026gt;3.5 and university=\u0026#39;山东大学\u0026#39;) or device_id in (select device_id from user_profile where gpa\u0026gt;3.8 and university=\u0026#39;复旦大学\u0026#39;) 牛客网题目\n查看学校名称中含北京的用户 题目：现在运营想查看所有大学中带有\u0026quot;北京\u0026quot;的用户的信息(device_id,age,university)，请你取出相应数据。\n字符匹配 四种通配符 % 匹配 0 个 或者是 多个字符 _ 匹配任意一个字符 _李 []匹配[]中任意一个字符,如果比较的字符串是连续的，可以用-表达 [^]不匹配[]中任意一个字符 1 select device_id, age, university from user_profile where university like \u0026#39;%北京%\u0026#39; ","date":"2025-05-06T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/senior-select-1/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/senior-select-1/","title":"[SQL] 高级操作符"},{"content":"计算函数 查找GPA最高值 题目：运营想要知道复旦大学学生gpa最高值是多少，请你取出相应数据\n关键点 max 四舍五入函数 round(value, pos) 1 2 3 4 5 6 7 8 select max(gpa) as gpa from user_profile where university = \u0026#39;复旦大学\u0026#39; limit 1; select round(max(gpa), 1) from user_profile where university=\u0026#39;复旦大学\u0026#39;; SELECT gpa FROM user_profile WHERE university = \u0026#39;复旦大学\u0026#39; ORDER BY gpa DESC LIMIT 1 计算男生人数以及平均GPA 题目：现在运营想要看一下男性用户有多少人以及他们的平均gpa是多少，用以辅助设计相关活动，请你取出相应数据。\n这里可以使用 count(*) 代替 count(gender) 1 select count(gender) as male_num ,avg(gpa) as avg_gpa from user_profile where gender = \u0026#39;male\u0026#39; 分组函数 分组计算练习题 题目：现在运营想要对每个学校不同性别的用户活跃情况和发帖数量进行分析，请分别计算出每个学校每种性别的用户数、30天内平均活跃天数和平均发帖数量。\n用户信息表：user_profile\n30天内活跃天数字段（active_days_within_30）\n发帖数量字段（question_cnt）\n回答数量字段（answer_cnt）\n没什么好说的, group by 多列的时候, 使用 , 进行区分 1 2 3 4 5 6 7 select gender,university, count(university) as user_num, avg(active_days_within_30) as avg_active_day, avg(question_cnt) as avg_question_cnt from user_profile group by gender, university order by gender asc, university asc 分组过滤练习题 题目：现在运营想查看每个学校用户的平均发贴和回帖情况，寻找低活跃度学校进行重点运营，请取出平均发贴数低于5的学校或平均回帖数小于20的学校。\n当使用聚合函数 作为塞选条件的时候，需要使用 where 代替 having 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SELECT university, avg_question_cnt, avg_answer_cnt FROM ( SELECT university, AVG(question_cnt) AS avg_question_cnt, AVG(answer_cnt) AS avg_answer_cnt FROM user_profile GROUP BY university ) AS temp WHERE avg_question_cnt \u0026lt; 5 OR avg_answer_cnt \u0026lt; 20; 正解应该是 :\n1 2 3 4 5 6 7 8 9 10 11 12 select university, round(avg(question_cnt),3) AS avg_question_cnt, round(AVG(answer_cnt),3) as avg_answer_cnt FROM user_profile GROUP BY university HAVING avg_question_cnt\u0026lt;5 or avg_answer_cnt\u0026lt;20 分组排序练习题 现在运营想要查看不同大学的用户平均发帖情况，并期望结果按照平均发帖情况进行升序排列，请你取出相应数据\n这里和 where不同，竟然不需要子查询和更换其他 关键字。 聚合函数可以直接进行排序 1 2 3 4 5 6 7 select university, avg_question_cnt from ( select university, avg(question_cnt) as avg_question_cnt from user_profile group by university ) as temp order by avg_question_cnt 正解 :\n1 2 3 4 5 6 7 8 9 SELECT university, ROUND(AVG(question_cnt), 4) AS avg_question_cnt FROM user_profile GROUP BY university ORDER BY avg_question_cnt; ","date":"2025-05-06T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/senior-select-2/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/senior-select-2/","title":"[SQL] 高级查询"},{"content":"资产策略现状 自从第一篇笔记开始，现在每天都有一个 todo list 需要给 binance 刷一下交易量，有点ptsd了 DATE BUY SELL DIFF 04-29 513 509 4U 04-30 513 509 4U 04-30 513 509 4U 05-01 513 509 4U 05-02 513 509 4U 05-03 513 511 2U 05-04 513 510 3U 目前总共磨损 4 *5 + 5 = 25U , 预计磨损 100U 破防。 按照 4 U 一天计算的话，大概还有25天破防 现在积分 85 , 最近一波在 5月7号，大概还有3天, 预计我还可以刷 22 分 ，也就是 118 . 预计是 140 ，大概是赶不上 binance 活动整理 双倍积分 BINANCE 推出积分双倍计算双倍活动 。 用交易所的限价单 和 BINANCE CHAIN 上刷交易量都是以双倍的形式计算 2. 即交易量 512 u 的 会以1024U计算，多个1积分 binance chain 暂时不考虑，手续费实在是太贵了 那么限价单是否有购买的必要呢 ？ 用限价单的话，大概率磨损会多个 1U - 2U ,多花个 1U - 2U 购买1积分 实际上很不划算 . 而且对于限价单, 需要把资产从钱包转移到交易所，很麻烦 。 新链 binance 钱包推出了 Sonic 链的项目。 对于活跃用户会有空投的奖励\n新币打新 OBOL 活动时间 5.7 号，18:00 不确定积分多少，预计要 130 . 大概率达不到 ~ ","date":"2025-05-04T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-1/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity-1/","title":"[Binance] 送钱活动 2"},{"content":"引导问题 整数求和 1 2 3 4 5 6 7 8 9 Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge). In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + ... + n. Input The input will consist of a series of integers n, one integer per line. Output For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer. 常规做法是 for-each 后对 sum 进行累加，然后输出 我们可以根据 等差数列高斯公式求得 (a + b) * n / 2 不过这题需要注意的是 4. 我们计算乘法的时候可能暴 int , 因为对于两个 int32 的数相乘必然会爆 int32 所以我们需要开辟成 int64 题目链接如下, 由于不支持 GO 所以不做\nhttps://vjudge.net/problem/HDU-1001\n例题 最小公倍数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 输入两个整数 a 和 b，请你编写一个函数，int lcm(int a, int b)，计算并输出 a 和 b 的最小公倍数。 输入格式 共一行，包含两个整数 a 和 b。 输出格式 共一行，包含一个整数，表示 a 和 b 的最小公倍数。 数据范围 1≤a,b≤1000 输入样例： 6 8 输出样例： 24 朴素做法\n我们从最大的数开始枚举，如 8,9,10\u0026hellip; 每次都判断是否能整除最小数 简单优化，我们可以直接枚举 最大数的倍数 。 可是最大数的倍数, 我们有很大概率爆int 的风险 正解\nlcm(A,B) = A * B / gcd(A,B) 优化一下 = A / gcd(A,B) * B 问题引导为 如何求最大公约数 Acwing-最小公倍数\n最大公约数 我们现在要求 10, 14 的最大公约数 。 我们假设 X 为这两个数的最大公约数，可以知道，对于 (14%10) 的余数，也应该是 X 的倍数 从而我们可以依次类推 (10,14) , (10,4) , (2,4), (2,0) 则 2 就是最大公约数 todo : 很抓马的一件事，我用 go 写这个程序 TLE 了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import( \u0026#34;fmt\u0026#34; ) func gcd(a,b int) int { if a \u0026gt; b { a,b = b,a } for ; a != 0 ; { a, b = b%a,a } return b } func main() { var n int fmt.Scan(\u0026amp;n) for i := 0 ; i \u0026lt; n ; i ++ { var a,b int fmt.Scan(\u0026amp;a,\u0026amp;b) fmt.Println(gcd(a,b)) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std ; int gcd(int a,int b) { int temp ; if(a \u0026gt; b) { temp = a; a = b ; b = temp; } for( ; a != 0 ; ) { temp = a; a = b%a; b = temp ; } return b ; } int main() { int a,b ; int n; cin\u0026gt;\u0026gt;n; for(int i = 1; i \u0026lt;= n ; i ++ ) { cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;gcd(a,b)\u0026lt;\u0026lt;endl; } } 循环节 - N * N 的个位数 Given a positive integer N, you should output the most right digit of N^N.\nInput\nThe input contains several test cases. The first line of the input is a single integer T which is the number of test cases.\nT test cases follow.\nEach test case contains a single positive integer N(1\u0026lt;=N\u0026lt;=1,000,000,000).\nOutput\nFor each test case, you should output the rightmost digit of N^N.\n时间范围 : T * N 必然做法是 T * O(K) 的\n2,4,8,16,32,64,128 ... 3,9,27,81,243 ... 显然，奇数 * 奇数 = 奇数 ， 偶数 * 偶数 = 偶数 。 个位上的偶数 也就 (0,2,4,6,8) , 奇数 (1,3,5,7,9) 所以肯定是一个循环, 因此我们只需要枚举出前5个,找出不重复的循环节即可解出这道题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { int t;cin\u0026gt;\u0026gt;t; while(t -- ) { int n ; cin \u0026gt;\u0026gt; n; int st[10] = {0}; int last = n % 10 ; int ans[6] = {0} ; int idx = 0 ; for(int i = 0 ; i \u0026lt; 5 ; i++ ) { int k = int(pow(last, i + 1)) % 10; if(st[k]){ break ; } ans[++idx] = k ; st[k] = 1 ; } ans[0] = ans[idx] ; cout\u0026lt;\u0026lt;ans[(n%(idx)) ] \u0026lt;\u0026lt;endl; idx = 0 ; } return 0; } 题目链接\n","date":"2025-05-04T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/hdu-0x01-math/icpc-title_hu_6183ef0f9981e0b9.png","permalink":"https://ddlgitgzzhm.github.io/p/hdu-0x01-math/","title":"[Hdu] 数学基础"},{"content":" 目前积分是 55 分 没想到短短 4 日，积分要求就从 45 飞到 80 ，整整长了 35 分 目前策略是 2 + 5 = 7 , 4 * 7 = 28 怎么都追不上 预计更换策略 2 + 9 = 11 , 4 * 11 = 44 (diff : 16) , ( diff calc per 16 * 4 = 64 ) 预计更换策略 512 一周，吃不到也没办法了 。\n预计每次磨损 8 刀左右，大概就是 8 * 7 = 56 刀 * 7.2 = 403.2 人名币\n积分计算规则 积分策略 最近活动 往期活动 ","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity/","title":"[Binance] 送钱活动"},{"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。\n示例 1：\n输入：nums = [1,1,1], k = 2\n输出：2\n示例 2：\n输入：nums = [1,2,3], k = 3\n输出：2\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104\n-1000 \u0026lt;= nums[i] \u0026lt;= 1000\n-107 \u0026lt;= k \u0026lt;= 107\n思路 对于 需要找到 X + Y = K 的模型，我们统一想到使用 map[X-K] = Y 的优化，可以将 n^2 -\u0026gt; O(n)\n对于这题我们需要把子数组和看为X, 我们计算前缀和 SUM[i] 表示，以 i 结尾前面所有数值的和. 因为我们知道 K 所以我们并不需要去找到我们的 Y, 我们只需要保证，我们能全量的枚举出X 即 SUM[i]\n因此我们只需要ans = ans + map[sum[i] - K] 即可\ntips :\n当我们 sum[1] - K == 2 并且在 sum[3] - K == 2 , 那么我们是否重复计算了 [0~3] 的某些子数组呢 ? 结论是 : 我们 sum[3]-K == 2 的成立是由于引入了A[2] , 因此不存在重复计算\n1 2 3 4 5 6 7 8 9 10 11 12 func subarraySum(nums []int, k int) int { count := make(map[int]int) count[0] = 1 preSum := 0 ans := 0 for _ , v := range nums { preSum += v ans += count[preSum - k] count[preSum] ++ } return ans } ","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/leetcode-560/img_hu_8844cfe45398f3ed.png","permalink":"https://ddlgitgzzhm.github.io/p/leetcode-560/","title":"[LeetCode][hot100] 560. 和为 K 的子数组"},{"content":"基础排序 查询后排序 asc 升序 ascending desc 降序 descending 1 select device_id, age from user_profile order by age asc 牛客网题目链接\n牛客网题目链接 (降序排列)\n查询后多列排序 多列排序使用, 隔开 不指定排序顺序，默认是 asc 1 2 3 4 5 select device_id,gpa,age from user_profile order by gpa asc, age asc SELECT device_id,gpa,age from user_profile order by gpa,age;默认以升序排列 SELECT device_id,gpa,age from user_profile order by gpa,age asc; SELECT device_id,gpa,age from user_profile order by gpa asc,age asc; 牛客网题目链接\n基础操作符 查找学校是北大的学生信息 我们可以通过 where 子句来筛选对应的记录 1 select device_id, university from user_profile where university = \u0026#39;北京大学\u0026#39; 该题背景 : device_id 和 university 为联合索引\n在这个背景下面，我们可以在查询的时候使用联合索引，少去一层回表查询的操作 todo , DBM 不会自己合上id吗\n1 Select device_id,university FROM user_profile where university = \u0026#34;北京大学\u0026#34; and device_id = user_profile.device_id; 牛客网题目链接\n查询年龄大于 24岁的用户信息 引入逻辑运算符 \u0026gt; 以此类推还有 \u0026lt; , = , \u0026gt;= , \u0026lt;= , != , = 1 select device_id, gender, age,university from user_profile where age \u0026gt; 24 [牛客网题目链接](select device_id, gender, age,university from user_profile where age \u0026gt; 24)\n查询某个年龄段的用户信息 使用 between and 和 \u0026gt;= and \u0026lt;= 没什么本质区别，性能和业务使用上无差别 不过相较于between and 逻辑表达式更灵活 1 2 3 4 5 select device_id, gender, age from user_profile where age \u0026gt;= 20 and age \u0026lt;= 23 SELECT device_id, gender, age FROM user_profile WHERE age BETWEEN 20 AND 23; 牛客网题目链接\n查找除复旦大学的用户信息 NOT IN 可以比较多个值, 对于 \u0026lt;\u0026gt; != 如果需要比较多个值需要引入 and \u0026lt;\u0026gt; 和 != 没有本质区别，不过一般都是写 \u0026lt;\u0026gt; 除非团队开发有要求，那么使用 != 尽可能统一组内的代码风格 1 2 3 select device_id,gender,age,university from user_profile where university \u0026lt;\u0026gt; \u0026#39;复旦大学\u0026#39; select device_id,gender,age,university from user_profile where university != \u0026#39;复旦大学\u0026#39; select device_id,gender,age,university from user_profile where university NOT IN (\u0026#34;复旦大学\u0026#34;) 牛客网题目链接\n用 where 过滤空值 可以单独是用 is not null 或者是单独使用 \u0026lt;\u0026gt; \u0026quot;\u0026quot; 但是实际业务最好是两个一起使用 ～ 1 2 3 select device_id,gender,age,university from user_profile where age is not null and age \u0026lt;\u0026gt; \u0026#34;\u0026#34; 牛客网题目链接\n","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/limit-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/limit-select/","title":"[SQL] 条件查询"},{"content":"查询所有列 两种做法,一种是 *, 另外一种是全量的显示所有的列。 本质上这两个没什么区别\n从业务角度来看\n如果当前的 sql 并不打算查新增的列 则可以使用第一种 如果后续有列被删除了, 第二种也需要同步改动(当然生产环境很少有直接删除的) 从索引角度来看\n如果 剩下的字段建立了二级索引，那么第二种方法可以避免一次回表操作 如果没有二级索引(二级缩影需要覆盖整个查询的列)这两个其实是一样的 1 2 SELECT * FROM user_profile SELECT id,device_id,gender,age,university,province FROM user_profile; 牛客网题目链接\n查询结果去重 select distinct 只用于列的去重 select group by 可以用于一些聚合操作 如 count , avg 1 2 select distinct university from user_profile select unviersity from user_profile group by unviersity 从性能上看\ndistinct 和 group by 没什么区别, 在只需要去重的场景 distinct 性能可能略好于 group by, 效率取决于 DISTINCT 从业务上看\n如果我们想要使用聚合函数, 如计算分组内的平均数 和 总数 那么必须使用 distinct 牛客网题目链接\n","date":"2025-04-24T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/primary-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/primary-select/","title":"[SQL] 基础查询"},{"content":"简要 对于一个温度显示系统，如果我们要显示不同的温度, 简单做法是直接写在一个 class 里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type tempV1 struct { temp float64 } func (t *tempV1) ShowCelsius() string { return fmt.Sprintf(\u0026#34;%.1f°C\u0026#34;, t.temp) } func (t *tempV1) ShowFahrenheit() string { return fmt.Sprintf(\u0026#34;%.1f°F\u0026#34;, t.temp*9/5+32) } func (t *tempV1) ShowKelvin() string { return fmt.Sprintf(\u0026#34;%.1fK\u0026#34;, t.temp+273.15) } 如果我们使用 SRP 的做法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type tempV2 struct{ temp float64 } func (t *tempV2) GetTemp() float64 { return t.temp } type TempDisplayed struct{ } func (d *TempDisplayed) Celsius(temp float64) string { return fmt.Sprintf(\u0026#34;%.1f°C\u0026#34;, temp) } func (d *TempDisplayed) Fahrenheit(temp float64) string { return fmt.Sprintf(\u0026#34;%.1f°F\u0026#34;, temp*9/5+32) } 从实际业务开发的角度来看\n第一种方法更适合做快速开发，也就是前期的造轮子阶段 第二种方法适合进行维护和新增以及复用功能 从微服务角度来看\n我们展示温度的功能应该单独的一个组件, 或者说是一个服务, 也就是我们如果新增了新的展示温度功能,我们不应该重启温度服务，只需要重启温度展示服务即可 从内存角度来看\n由于我们新增的 TempDisplayed 并没有实际的 VALUE,属于无状态的 CLASS , 不占用额外内存。从 BenchMark 的结果来看，每次操作内存分配次数都是 4 allocs/op, 每次操作分配字节数都是 32B/op 和预期的一样 即我们并没有花更多的内存代价,就实现了代码服务的隔离 1 2 3 4 5 pkg: GolangLearning/design-pattern cpu: 12th Gen Intel(R) Core(TM) i5-12400 BenchmarkTempV1_Allocs-12 3861781 310.1 ns/op 32 B/op 4 allocs/op BenchmarkTempV2_Allocs-12 3682756 290.2 ns/op 32 B/op 4 allocs/op PASS [留坑]进阶 todo\n参考 https://juejin.cn/post/6967279849597566984?searchId=2025042323171433459C03C38A4C01D6A7 https://juejin.cn/post/7385388449618493477?searchId=2025042323171433459C03C38A4C01D6A7\n","date":"2025-04-24T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/srp/srp_hu_d90b5e254788e6e7.png","permalink":"https://ddlgitgzzhm.github.io/p/srp/","title":"[设计模式] SRP 单一职责原则"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n","date":"2020-09-09T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://ddlgitgzzhm.github.io/p/test-chinese/","title":"文章的起源"}]