[{"content":" 目前积分是 55 分 没想到短短 4 日，积分要求就从 45 飞到 80 ，整整长了 35 分 目前策略是 2 + 5 = 7 , 4 * 7 = 28 怎么都追不上 预计更换策略 2 + 9 = 11 , 4 * 11 = 44 (diff : 16) , ( diff calc per 16 * 4 = 64 ) 预计更换策略 512 一周，吃不到也没办法了 。\n预计每次磨损 8 刀左右，大概就是 8 * 7 = 56 刀 * 7.2 = 403.2 人名币\n积分计算规则 积分策略 最近活动 往期活动 ","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/binance-staking-activity/img_hu_95ff393f095eea47.png","permalink":"https://ddlgitgzzhm.github.io/p/binance-staking-activity/","title":"[Binance] 送钱活动"},{"content":" 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。\n示例 1：\n输入：nums = [1,1,1], k = 2\n输出：2\n示例 2：\n输入：nums = [1,2,3], k = 3\n输出：2\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104\n-1000 \u0026lt;= nums[i] \u0026lt;= 1000\n-107 \u0026lt;= k \u0026lt;= 107\n思路 对于 需要找到 X + Y = K 的模型，我们统一想到使用 map[X-K] = Y 的优化，可以将 n^2 -\u0026gt; O(n)\n对于这题我们需要把子数组和看为X, 我们计算前缀和 SUM[i] 表示，以 i 结尾前面所有数值的和. 因为我们知道 K 所以我们并不需要去找到我们的 Y, 我们只需要保证，我们能全量的枚举出X 即 SUM[i]\n因此我们只需要ans = ans + map[sum[i] - K] 即可\ntips :\n当我们 sum[1] - K == 2 并且在 sum[3] - K == 2 , 那么我们是否重复计算了 [0~3] 的某些子数组呢 ? 结论是 : 我们 sum[3]-K == 2 的成立是由于引入了A[2] , 因此不存在重复计算\n1 2 3 4 5 6 7 8 9 10 11 12 func subarraySum(nums []int, k int) int { count := make(map[int]int) count[0] = 1 preSum := 0 ans := 0 for _ , v := range nums { preSum += v ans += count[preSum - k] count[preSum] ++ } return ans } ","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/leetcode-560/img_hu_8844cfe45398f3ed.png","permalink":"https://ddlgitgzzhm.github.io/p/leetcode-560/","title":"[LeetCode][hot100] 560. 和为 K 的子数组"},{"content":"1. 基础排序 1. 查询后排序 asc 升序 ascending desc 降序 descending 1 select device_id, age from user_profile order by age asc 牛客网题目链接\n牛客网题目链接 (降序排列)\n2. 查询后多列排序 多列排序使用, 隔开 不指定排序顺序，默认是 asc 1 2 3 4 5 select device_id,gpa,age from user_profile order by gpa asc, age asc SELECT device_id,gpa,age from user_profile order by gpa,age;默认以升序排列 SELECT device_id,gpa,age from user_profile order by gpa,age asc; SELECT device_id,gpa,age from user_profile order by gpa asc,age asc; 牛客网题目链接\n2. 基础操作符 1. 查找学校是北大的学生信息 我们可以通过 where 子句来筛选对应的记录 1 select device_id, university from user_profile where university = \u0026#39;北京大学\u0026#39; 该题背景 : device_id 和 university 为联合索引\n在这个背景下面，我们可以在查询的时候使用联合索引，少去一层回表查询的操作 todo , DBM 不会自己合上id吗\n1 Select device_id,university FROM user_profile where university = \u0026#34;北京大学\u0026#34; and device_id = user_profile.device_id; 牛客网题目链接\n2. 查询年龄大于 24岁的用户信息 引入逻辑运算符 \u0026gt; 以此类推还有 \u0026lt; , = , \u0026gt;= , \u0026lt;= , != , = 1 select device_id, gender, age,university from user_profile where age \u0026gt; 24 [牛客网题目链接](select device_id, gender, age,university from user_profile where age \u0026gt; 24)\n3. 查询某个年龄段的用户信息 使用 between and 和 \u0026gt;= and \u0026lt;= 没什么本质区别，性能和业务使用上无差别 不过相较于between and 逻辑表达式更灵活 1 2 3 4 5 select device_id, gender, age from user_profile where age \u0026gt;= 20 and age \u0026lt;= 23 SELECT device_id, gender, age FROM user_profile WHERE age BETWEEN 20 AND 23; 牛客网题目链接\n4. 查找除复旦大学的用户信息 NOT IN 可以比较多个值, 对于 \u0026lt;\u0026gt; != 如果需要比较多个值需要引入 and \u0026lt;\u0026gt; 和 != 没有本质区别，不过一般都是写 \u0026lt;\u0026gt; 除非团队开发有要求，那么使用 != 尽可能统一组内的代码风格 1 2 3 select device_id,gender,age,university from user_profile where university \u0026lt;\u0026gt; \u0026#39;复旦大学\u0026#39; select device_id,gender,age,university from user_profile where university != \u0026#39;复旦大学\u0026#39; select device_id,gender,age,university from user_profile where university NOT IN (\u0026#34;复旦大学\u0026#34;) 牛客网题目链接\n5. 用 where 过滤空值 可以单独是用 is not null 或者是单独使用 \u0026lt;\u0026gt; \u0026quot;\u0026quot; 但是实际业务最好是两个一起使用 ～ 1 2 3 select device_id,gender,age,university from user_profile where age is not null and age \u0026lt;\u0026gt; \u0026#34;\u0026#34; 牛客网题目链接\n","date":"2025-04-29T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/limit-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/limit-select/","title":"[SQL] 条件查询"},{"content":"1. 查询所有列 两种做法,一种是 *, 另外一种是全量的显示所有的列。 本质上这两个没什么区别\n从业务角度来看\n如果当前的 sql 并不打算查新增的列 则可以使用第一种 如果后续有列被删除了, 第二种也需要同步改动(当然生产环境很少有直接删除的) 从索引角度来看\n如果 剩下的字段建立了二级索引，那么第二种方法可以避免一次回表操作 如果没有二级索引(二级缩影需要覆盖整个查询的列)这两个其实是一样的 1 2 SELECT * FROM user_profile SELECT id,device_id,gender,age,university,province FROM user_profile; 牛客网题目链接\n2. 查询结果去重 select distinct 只用于列的去重 select group by 可以用于一些聚合操作 如 count , avg 1 2 select distinct university from user_profile select unviersity from user_profile group by unviersity 从性能上看\ndistinct 和 group by 没什么区别, 在只需要去重的场景 distinct 性能可能略好于 group by, 效率取决于 DISTINCT 从业务上看\n如果我们想要使用聚合函数, 如计算分组内的平均数 和 总数 那么必须使用 distinct 牛客网题目链接\n","date":"2025-04-24T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/primary-select/sql_hu_c813795690966d5c.png","permalink":"https://ddlgitgzzhm.github.io/p/primary-select/","title":"[SQL] 基础查询"},{"content":"简要 对于一个温度显示系统，如果我们要显示不同的温度, 简单做法是直接写在一个 class 里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type tempV1 struct { temp float64 } func (t *tempV1) ShowCelsius() string { return fmt.Sprintf(\u0026#34;%.1f°C\u0026#34;, t.temp) } func (t *tempV1) ShowFahrenheit() string { return fmt.Sprintf(\u0026#34;%.1f°F\u0026#34;, t.temp*9/5+32) } func (t *tempV1) ShowKelvin() string { return fmt.Sprintf(\u0026#34;%.1fK\u0026#34;, t.temp+273.15) } 如果我们使用 SRP 的做法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type tempV2 struct{ temp float64 } func (t *tempV2) GetTemp() float64 { return t.temp } type TempDisplayed struct{ } func (d *TempDisplayed) Celsius(temp float64) string { return fmt.Sprintf(\u0026#34;%.1f°C\u0026#34;, temp) } func (d *TempDisplayed) Fahrenheit(temp float64) string { return fmt.Sprintf(\u0026#34;%.1f°F\u0026#34;, temp*9/5+32) } 从实际业务开发的角度来看\n第一种方法更适合做快速开发，也就是前期的造轮子阶段 第二种方法适合进行维护和新增以及复用功能 从微服务角度来看\n我们展示温度的功能应该单独的一个组件, 或者说是一个服务, 也就是我们如果新增了新的展示温度功能,我们不应该重启温度服务，只需要重启温度展示服务即可 从内存角度来看\n由于我们新增的 TempDisplayed 并没有实际的 VALUE,属于无状态的 CLASS , 不占用额外内存。从 BenchMark 的结果来看，每次操作内存分配次数都是 4 allocs/op, 每次操作分配字节数都是 32B/op 和预期的一样 即我们并没有花更多的内存代价,就实现了代码服务的隔离 1 2 3 4 5 pkg: GolangLearning/design-pattern cpu: 12th Gen Intel(R) Core(TM) i5-12400 BenchmarkTempV1_Allocs-12 3861781 310.1 ns/op 32 B/op 4 allocs/op BenchmarkTempV2_Allocs-12 3682756 290.2 ns/op 32 B/op 4 allocs/op PASS 进阶 todo\n参考 https://juejin.cn/post/6967279849597566984?searchId=2025042323171433459C03C38A4C01D6A7 https://juejin.cn/post/7385388449618493477?searchId=2025042323171433459C03C38A4C01D6A7\n","date":"2025-04-24T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/srp/srp_hu_d90b5e254788e6e7.png","permalink":"https://ddlgitgzzhm.github.io/p/srp/","title":"[设计模式] SRP 单一职责原则"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n","date":"2020-09-09T00:00:00Z","image":"https://ddlgitgzzhm.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://ddlgitgzzhm.github.io/p/test-chinese/","title":"文章的起源"}]